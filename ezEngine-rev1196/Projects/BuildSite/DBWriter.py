from DBAccess import DBAccess
import pysvn
import requests
from flask import Flask, json

class DBWriter:
    """Class that encapsulates the conversion of json build results into database records.
    Also handles the retrival of revision information from the SVN server (commits message etc)."""
    ########################################################################
    ## DBWriter constructor
    ########################################################################
    def __init__(self, dbAccess, app):
        self.DB = dbAccess
        self.config = app.config
        self.callback_SendMail = None


    ########################################################################
    ## DBWriter public functions
    ########################################################################
    def AddBuildProcessResult(self, json):
        """The parameter 'json' is the entire json output of a build, i.e. the files generated by the build machines
        and sent to the CNC tool which in turn sends them here."""
        db = self.DB.getDB()

        # Get or add build machine
        buildMachineId = self.AddBuildMachine(json['Settings'])

        # Revision / Timestamp
        revision = json['Settings']['Revision']
        timestamp = json['Settings']['Timestamp']

        # Get old entry if it exists
        cur = db.execute('SELECT * FROM BuildProcessResults WHERE Revision=? AND BuildMachine=?',
                         (revision, buildMachineId))
        buildProcessResult = cur.fetchall()
        if buildProcessResult:
            # If the duration is equal this BuildProcessResult is already present in the DB and we can early out.
            if buildProcessResult[0]['Duration'] == json['Duration']:
                return buildProcessResult[0][0]

            # If the new BuildProcessResult is different, we delete the old one (cascades)
            res = db.execute('DELETE FROM BuildProcessResults WHERE id=?', (buildProcessResult[0][0],))

        # Insert new entry
        res = db.execute('INSERT INTO BuildProcessResults (Revision, Timestamp, Success, Duration, Errors, BuildMachine) values (?, ?, ?, ?, ?, ?)',
                         (revision, timestamp, json['Success'], json['Duration'], json['Errors'], buildMachineId) )
        buildProcessId = res.lastrowid

        # Add all sub-entries
        self.AddSVNResult(json['SVNResult'], buildProcessId)
        self.AddCMakeResult(json['CMakeResult'], buildProcessId)
        self.AddBuildResult(json['BuildResult'], buildProcessId)
        self.AddTestResult(json['TestResult'], buildProcessId)

        # Sync revision information from the SVN server.
        self.UpdateSVNRevisions()

        # Commit to DB, this should be the only commit in the entire class as all other functions are called from here.
        db.commit()

        self.CheckToSendMail(revision)
        return buildProcessId


    ########################################################################
    ## DBWriter private functions
    ########################################################################
    def CheckToSendMail(self, rev):
        if (not self.callback_SendMail):
            return

        db = self.DB.getDB()
        cur = db.execute('SELECT COUNT(*) FROM BuildProcessResults WHERE Revision=?', (rev,))
        buildResultCount = cur.fetchall()[0][0]

        cur = db.execute('SELECT COUNT(*) FROM BuildMachines')
        buildMachineCount = cur.fetchall()[0][0]

        if (buildResultCount == buildMachineCount):
            # Sanity check: we do not send an email if the current revision is more than 10
            # revisions behind the head revision. Just to be sure this doesn't end in an
            # unfortunate mail spam meltdown.
            cur = db.execute('SELECT MAX(id) FROM Revisions')
            entries = cur.fetchall()
            if (rev + 10 < entries[0][0]):
                return

            cur = db.execute('SELECT Author FROM Revisions WHERE id=?', (rev,))
            AuthorEntry = cur.fetchall()
            if (not AuthorEntry):
                return

            try:
                # Get the email address of the author and call the send mail callback.
                Author = AuthorEntry[0][0]
                response = requests.get(self.config['SVN_USER_TO_MAIL_REQUEST_ADDRESS'] + Author)
                responseJson = json.loads(response.content)
                AuthorMail = responseJson[Author]
                self.callback_SendMail(rev, AuthorMail)
            except:
                app.logger.debug('*** CheckToSendMail: Unexpected error: %s', sys.exc_info()[0])
        return


    def UpdateSVNRevisions(self):
        """Updates the 'Revisions' table to have an entry for every revision that we have build data for."""
        # SVN setup
        svn_api = pysvn.Client()
        svn_api.callback_ssl_server_trust_prompt = self.ssl_server_trust_prompt
        svn_api.callback_get_login = self.svn_get_login

        db = self.DB.getDB()
        # Test if there is a revision for which we currently have build data but no revision data.
        cur = db.execute('SELECT DISTINCT Revision FROM BuildProcessResults WHERE Revision NOT IN (SELECT id FROM Revisions) ORDER BY Revision ASC')
        revisionList = cur.fetchall()
        if (not revisionList):
            return

        # Get all from the first entry that we are missing up to HEAD.
        revStart = pysvn.Revision( pysvn.opt_revision_kind.number, revisionList[0][0] )
        revHead = pysvn.Revision( pysvn.opt_revision_kind.head )
        revlog = svn_api.log(self.config['SVN_ROOT'], revision_start=revStart, revision_end=revHead, discover_changed_paths=True)

        # Add SVN results to the database
        for pySvnLog in revlog:
            # Test whether we already have data for this revision
            cur = db.execute('SELECT id FROM Revisions WHERE id=?', (pySvnLog.data['revision'].number,))
            rev = cur.fetchall()
            if not rev:
                changedPaths = '';
                # Concatenate all touched files with their action into one string.
                for entry in pySvnLog.data['changed_paths']:
                    changedPaths += (entry.data['action'] + ' ' + entry.data['path'] + "\n")
                # Insert into table
                res = db.execute('INSERT INTO Revisions (id, Date, Author, Message, ChangedPaths) values (?, ?, ?, ?, ?)',
                        (pySvnLog.data['revision'].number, long(pySvnLog.data['date']), pySvnLog.data['author'], pySvnLog.data['message'], changedPaths) )

        # This function is only called by 'AddBuildProcessResult', so no DB commit here.
        return

    def ssl_server_trust_prompt(trust_dict):
        return True, 5, True

    def svn_get_login(realm, username, may_save):
        return True, self.config['SVN_USER'], self.config['SVN_PASS'], False


    def AddBuildMachine(self, jsonConfiguration):
        """Returns the id of the BuildMachine referenced by the given configuration,
        if no entry exists yet it is created."""
        db = self.DB.getDB()
        # Test whether we already have this build machine
        cur = db.execute('SELECT id FROM BuildMachines WHERE ConfigurationName=?', (jsonConfiguration['ConfigurationName'],))
        machine = cur.fetchall()
        machineId = 0
        if not machine:
            res = db.execute('INSERT INTO BuildMachines (Configuration, ConfigurationName, DirectHardwareAccess) values (?, ?, ?)',
                             (jsonConfiguration['Configuration'], jsonConfiguration['ConfigurationName'], jsonConfiguration['DirectHardwareAccess']) )
            machineId = res.lastrowid
        else:
            machineId = machine[0][0]

        return machineId


    def AddSVNResult(self, jsonSVNResult, buildProcessId):
        db = self.DB.getDB()

        res = db.execute('INSERT INTO SVNResults (Success, Duration, Errors, BuildProcessResult) values (?, ?, ?, ?)',
                         (jsonSVNResult['Success'], jsonSVNResult['Duration'], jsonSVNResult['Errors'], buildProcessId) )
        SVNResultId = res.lastrowid

        jsonProcessRes = jsonSVNResult['ProcessRes']
        if (not jsonProcessRes):
            return
        res = db.execute('INSERT INTO ProcessResults (ExitCode, StdOut, ErrorOut, Duration, SVNResult) values (?, ?, ?, ?, ?)',
                         (jsonProcessRes['ExitCode'], jsonProcessRes['StdOut'], jsonProcessRes['ErrorOut'], jsonProcessRes['Duration'], SVNResultId) )
        return


    def AddCMakeResult(self, jsonCMakeResult, buildProcessId):
        db = self.DB.getDB()

        res = db.execute('INSERT INTO CMakeResults (Success, Duration, Errors, BuildProcessResult) values (?, ?, ?, ?)',
                         (jsonCMakeResult['Success'], jsonCMakeResult['Duration'], jsonCMakeResult['Errors'], buildProcessId) )
        CMakeResultId = res.lastrowid

        jsonProcessRes = jsonCMakeResult['ProcessRes']
        if (not jsonProcessRes):
            return
        res = db.execute('INSERT INTO ProcessResults (ExitCode, StdOut, ErrorOut, Duration, CMakeResult) values (?, ?, ?, ?, ?)',
                         (jsonProcessRes['ExitCode'], jsonProcessRes['StdOut'], jsonProcessRes['ErrorOut'], jsonProcessRes['Duration'], CMakeResultId) )
        return


    def AddBuildResult(self, jsonBuildResult, buildProcessId):
        db = self.DB.getDB()

        res = db.execute('INSERT INTO BuildResults (Success, Duration, Errors, BuildProcessResult) values (?, ?, ?, ?)',
                         (jsonBuildResult['Success'], jsonBuildResult['Duration'], jsonBuildResult['Errors'], buildProcessId) )
        buildResultId = res.lastrowid

        # Add all build targets
        for jsonBuildTargetResult in jsonBuildResult['BuildTargetResults']:
            # Add BuildTargetResult
            res = db.execute('INSERT INTO BuildTargetResults (Name, Experimental, Success, Duration, Errors, BuildResult) values (?, ?, ?, ?, ?, ?)',
                             (jsonBuildTargetResult['Name'], jsonBuildTargetResult['Experimental'], jsonBuildTargetResult['Success'],
                              jsonBuildTargetResult['Duration'], jsonBuildTargetResult['Errors'], buildResultId) )
            buildTargetResultId = res.lastrowid
            # Add ProcessRes
            jsonProcessRes = jsonBuildTargetResult['ProcessRes']
            if (not jsonProcessRes):
                continue
            res = db.execute('INSERT INTO ProcessResults (ExitCode, StdOut, ErrorOut, Duration, BuildTargetResult) values (?, ?, ?, ?, ?)',
                             (jsonProcessRes['ExitCode'], jsonProcessRes['StdOut'], jsonProcessRes['ErrorOut'], jsonProcessRes['Duration'], buildTargetResultId) )
        return


    def AddTestResult(self, jsonTestResult, buildProcessId):
        db = self.DB.getDB()

        res = db.execute('INSERT INTO TestResults (Success, Duration, Errors, BuildProcessResult) values (?, ?, ?, ?)',
                         (jsonTestResult['Success'], jsonTestResult['Duration'], jsonTestResult['Errors'], buildProcessId) )
        testResultId = res.lastrowid

        # Add all test targets
        for jsonTestTargetResult in jsonTestResult['TestTargetResults']:
            # Add TestTargetResult
            res = db.execute('INSERT INTO TestTargetResults (Name, NeedsHardwareAccess, Experimental, Success, Duration, Errors, TestResult) values (?, ?, ?, ?, ?, ?, ?)',
                             (jsonTestTargetResult['Name'], jsonTestTargetResult['NeedsHardwareAccess'], jsonTestTargetResult['Experimental'], jsonTestTargetResult['Success'],
                              jsonTestTargetResult['Duration'], jsonTestTargetResult['Errors'], testResultId) )
            testTargetResultId = res.lastrowid
            # Add ProcessRes
            jsonProcessRes = jsonTestTargetResult['ProcessRes']
            if (not jsonProcessRes):
                continue
            res = db.execute('INSERT INTO ProcessResults (ExitCode, StdOut, ErrorOut, Duration, TestTargetResult) values (?, ?, ?, ?, ?)',
                             (jsonProcessRes['ExitCode'], jsonProcessRes['StdOut'], jsonProcessRes['ErrorOut'], jsonProcessRes['Duration'], testTargetResultId) )
        return


    ########################################################################
    ## DBWriter private fields
    ########################################################################
    DB = None
    config = None
    callback_SendMail = None